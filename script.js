// --- Constants and State ---
// IMPORTANT: Replace with your WebSocket bridge URL if you implement one
// Use "ws://localhost:8080" for the Java bridge
// Use "ws://localhost:8080/bridge" for the Perl bridge
const WEBSOCKET_SERVER_URL = "ws://localhost:8080"; // Adjust if needed
const USER_PREFIX = "USER:";
const MSG_PREFIX = "MSG:";
const CMD_HELP = "/help";
const CMD_USERS = "/users";

let websocket = null;
let username = null;
let users = [];
let isConnected = false;

// --- DOM Elements ---
const loginModal = document.getElementById('loginModal');
const loginForm = document.getElementById('loginForm');
const usernameInput = document.getElementById('usernameInput');
const connectButton = document.getElementById('connectButton');
const loginError = document.getElementById('loginError');

const chatbox = document.getElementById('chatbox');
const chatboxWrapper = document.getElementById('chatboxWrapper');
const messageForm = document.getElementById('messageForm');
const messageInput = document.getElementById('messageInput');
const sendButton = document.getElementById('sendButton');
const statusDiv = document.getElementById('status');
const userListUl = document.getElementById('userList');
const userCountSpan = document.getElementById('userCount');

// --- Utility Functions ---

/**
 * Gets the current time formatted as HH:MM:SS.
 * @returns {string} Formatted timestamp.
 */
function getCurrentTimestamp() {
    const now = new Date();
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    return `${hours}:${minutes}:${seconds}`;
}

/**
 * Validates the username format (client-side).
 * @param {string} name - The username to validate.
 * @returns {boolean} True if the format is valid, false otherwise.
 */
function isValidUsername(name) {
    if (!name || name.length < 3 || name.length > 15) return false;
    // Allow letters, numbers, underscore, hyphen. No spaces.
    return /^[a-zA-Z0-9_-]+$/.test(name);
}

/**
 * Scrolls the chatbox wrapper to the bottom.
 */
function scrollToBottom() {
    // Set the scroll position to the maximum scroll height
    chatboxWrapper.scrollTop = chatboxWrapper.scrollHeight;
}

/**
 * Adds a message to the chat interface, parsing and styling it appropriately.
 * Appends the message to the end of the chatbox.
 * @param {string} rawMessage - The raw message string received from the server or generated by the client.
 */
function addMessageToChat(rawMessage) {
    const messageContainer = document.createElement('div');
    messageContainer.classList.add('message-container');

    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');

    const messageP = document.createElement('p');
    messageP.classList.add('message-content');

    const timeP = document.createElement('p');
    timeP.classList.add('timestamp');

    let sender = null;
    let content = rawMessage;
    let timestamp = getCurrentTimestamp(); // Default to now if parsing fails
    let messageType = 'system'; // default type

    // Try to parse server format: "[HH:mm:ss] [Sender]: Content" or "[HH:mm:ss] [Sistema] Content"
    const timeMatch = rawMessage.match(/^\[(\d{2}:\d{2}:\d{2})\]\s?/);
    if (timeMatch) {
        timestamp = timeMatch[1];
        content = rawMessage.substring(timeMatch[0].length).trim(); // Content after timestamp

        const systemMatch = content.match(/^\[(Sistema)\](?:[:\s]\s*)?(.*)/i);
        const senderMatch = content.match(/^\[(.*?)\]:\s*(.*)/);

        if (systemMatch) {
            sender = systemMatch[1]; // "Sistema"
            content = systemMatch[2].trim();
            messageType = 'system';
            messageDiv.classList.add('system-message');
            messageContainer.classList.add('self-center');
        } else if (senderMatch) {
            sender = senderMatch[1];
            content = senderMatch[2].trim();
            if (sender === username) {
                messageType = 'my-message';
                messageDiv.classList.add('my-message');
                messageContainer.classList.add('self-end');
            } else {
                messageType = 'other-user';
                messageDiv.classList.add('other-message');
                messageContainer.classList.add('self-start');
            }
        } else {
            messageType = 'system';
            messageDiv.classList.add('system-message');
            messageContainer.classList.add('self-center');
            sender = 'Sistema';
        }
    } else {
        messageType = 'client-info';
        messageDiv.classList.add('client-info-message');
        messageContainer.classList.add('self-center');
        sender = 'Client Info';
    }

    const senderSpan = document.createElement('span');
    senderSpan.classList.add('sender');
    if (sender) {
        senderSpan.classList.add(`${messageType}-sender`);
        senderSpan.textContent = `[${sender}]: `;
        if (messageType !== 'my-message') {
             messageP.appendChild(senderSpan);
        }
    }

    messageP.appendChild(document.createTextNode(content));
    timeP.textContent = timestamp;

    messageDiv.appendChild(messageP);
    if (messageType !== 'client-info') {
        messageDiv.appendChild(timeP);
    }
    messageContainer.appendChild(messageDiv);

    // Append the new message to the end of the chatbox
    chatbox.appendChild(messageContainer);

    // Special handling for user list updates
    if (messageType === 'system' && content.toLowerCase().startsWith('usuarios conectados')) {
        parseAndUpdateUserList(content);
    }

    // Scroll to the bottom after adding the message
    scrollToBottom();
}


/**
 * Updates the user list display in the sidebar.
 */
function updateUserListDisplay() {
    userListUl.innerHTML = ''; // Clear existing list
    users.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
    users.forEach(user => {
        const li = document.createElement('li');
        li.textContent = user;
        userListUl.appendChild(li);
    });
    userCountSpan.textContent = users.length;
}

/**
 * Parses the user list string from the server and updates the local 'users' array.
 * @param {string} userListContent - The content part of the user list message.
 */
function parseAndUpdateUserList(userListContent) {
    const userPartMatch = userListContent.match(/:\s*(.*)$/);
    const userPart = userPartMatch ? userPartMatch[1].trim() : '';

    if (userPart && userPart.toLowerCase() !== '(ninguno)') {
        users = userPart.split(',')
                      .map(name => name.trim())
                      .filter(name => name.length > 0);
    } else {
        users = [];
    }
    updateUserListDisplay();
}


/**
 * Updates the UI elements based on connection status.
 * @param {boolean} connected - True if connected, false otherwise.
 */
function updateUIState(connected) {
    isConnected = connected; // Update the global state flag
    // console.log(`DEBUG: updateUIState called with connected = ${connected}`); // Debug log
    if (connected) {
        loginModal.classList.add('hidden');
        messageInput.disabled = false;
        sendButton.disabled = false;
        statusDiv.textContent = `Estado: Conectado como ${username}`;
        statusDiv.style.color = '#a5d6a7';
        messageInput.focus();
    } else {
        loginModal.classList.remove('hidden');
        messageInput.disabled = true;
        sendButton.disabled = true;
        username = null;
        users = [];
        updateUserListDisplay();
        statusDiv.textContent = "Estado: Desconectado";
        statusDiv.style.color = '#ef9a9a';
        loginError.textContent = '';
    }
}


// --- WebSocket Event Handlers ---

/**
 * Called when the WebSocket connection is successfully opened.
 * @param {Event} event - The WebSocket open event.
 */
function handleOpen(event) {
    // console.log("DEBUG: WebSocket handleOpen event fired."); // Debug log
    loginError.textContent = '';
    const userCommand = `${USER_PREFIX}${username}`;
    console.log("Sending identification:", userCommand);
    websocket.send(userCommand);
    statusDiv.textContent = `Estado: Identificando como ${username}...`;
    statusDiv.style.color = '#fff59d';
}

/**
 * Called when a message is received from the WebSocket server.
 * @param {MessageEvent} event - The WebSocket message event.
 */
function handleMessage(event) {
    const message = event.data;
    console.log("Received message:", message);

    // Check for welcome message to transition UI state
    if (message.includes(`Â¡Bienvenido al chat, ${username}!`)) {
        // console.log("DEBUG: Welcome message received."); // Debug log
        if (!isConnected) {
            // console.log("DEBUG: Setting UI state to connected."); // Debug log
            updateUIState(true); // Mark as fully connected *after* receiving welcome
        } else {
             // console.log("DEBUG: Already connected, ignoring duplicate welcome message."); // Debug log
        }
    }
    // Add message to chat only if it's NOT our own message (already handled by local echo)
    // We identify own messages by checking if the sender part matches the current username
    const senderMatch = message.match(/^\[\d{2}:\d{2}:\d{2}\]\s+\[(.*?)\]:/);
    if (!senderMatch || senderMatch[1] !== username) {
        addMessageToChat(message);
    } else {
        // Optional: Log that we are ignoring the echo of our own message
        console.log("DEBUG: Ignoring server echo of own message:", message);
    }
}

/**
 * Called when a WebSocket error occurs.
 * @param {Event} event - The WebSocket error event.
 */
function handleError(event) {
    console.error("WebSocket Error:", event);
    addMessageToChat(`[Client Info] Error de WebSocket. Revisa la consola.`);
    if (!loginModal.classList.contains('hidden')) {
        loginError.textContent = "Error de conexiÃ³n.";
    }
    updateUIState(false);
}

/**
 * Called when the WebSocket connection is closed.
 * @param {CloseEvent} event - The WebSocket close event.
 */
function handleClose(event) {
    // console.log("DEBUG: WebSocket handleClose event fired."); // Debug log
    console.log("WebSocket connection closed:", `Code: ${event.code}`, `Reason: ${event.reason}`, `Was clean: ${event.wasClean}`);
    const wasConnected = isConnected;
    updateUIState(false); // Set UI to disconnected state

    if (wasConnected) {
        addMessageToChat(`[Client Info] Desconectado del servidor.`);
    } else if (!event.wasClean && username) {
        loginError.textContent = "Fallo al conectar. Nombre en uso o servidor caÃ­do.";
    }
    websocket = null; // Clear the WebSocket object reference
}

// --- Connection Logic ---

/**
 * Attempts to establish a WebSocket connection.
 * @param {string} chosenUsername - The username selected.
 */
function connect(chosenUsername) {
    if (!isValidUsername(chosenUsername)) {
        loginError.textContent = "Formato de nombre de usuario invÃ¡lido.";
        return;
    }
    username = chosenUsername;
    loginError.textContent = '';
    statusDiv.textContent = "Estado: Conectando...";
    statusDiv.style.color = '#fff59d';

    try {
        const wsUrl = WEBSOCKET_SERVER_URL;
        console.log(`Attempting to connect to WebSocket server: ${wsUrl}`);
        websocket = new WebSocket(wsUrl); // Assign to the global websocket variable
        // console.log("DEBUG: WebSocket object created:", websocket); // Debug log

        // Assign event handlers
        websocket.onopen = handleOpen;
        websocket.onmessage = handleMessage;
        websocket.onerror = handleError;
        websocket.onclose = handleClose;

    } catch (error) {
         console.error("Failed to create WebSocket:", error);
         loginError.textContent = "Fallo al iniciar conexiÃ³n.";
         statusDiv.textContent = "Estado: Error";
         statusDiv.style.color = '#ef9a9a';
         updateUIState(false);
    }
}

// --- Event Listeners ---

/** Handles login form submission. */
loginForm.addEventListener('submit', (e) => {
    e.preventDefault();
    // console.log("DEBUG: Login form submitted."); // Debug log
    connect(usernameInput.value.trim());
});

/** Handles message form submission. */
messageForm.addEventListener('submit', (e) => {
    e.preventDefault(); // Prevent default form submission
    // console.log("DEBUG: Message form submitted."); // Debug log

    const messageText = messageInput.value.trim();
    // console.log(`DEBUG: Message text: "${messageText}", isConnected: ${isConnected}`); // Debug log

    // Don't send empty messages or if not connected
    if (!messageText || !isConnected) {
        // console.log("DEBUG: Send condition not met (empty message or not connected). Aborting send."); // Debug log
        return;
    }

    let messageToSend;
    // Format message with prefix
    if (messageText.toLowerCase() === CMD_HELP || messageText.toLowerCase() === CMD_USERS) {
        messageToSend = `${MSG_PREFIX}${messageText}`;
    } else {
        messageToSend = `${MSG_PREFIX}${messageText}`;
    }
    // console.log("DEBUG: Formatted message to send:", messageToSend); // Debug log

    // Check WebSocket object and state before sending
    // console.log("DEBUG: Checking WebSocket state before send. websocket:", websocket); // Debug log
    // if (websocket) {
    //      console.log(`DEBUG: websocket.readyState: ${websocket.readyState} (OPEN is ${WebSocket.OPEN})`); // Debug log
    // }

    if (websocket && websocket.readyState === WebSocket.OPEN) {
        try {
            // console.log("DEBUG: Attempting websocket.send()."); // Debug log
            websocket.send(messageToSend); // Send to server/bridge
            // console.log("DEBUG: websocket.send() executed."); // Debug log

            // --- BEGIN LOCAL ECHO ---
            // Format the message as if it were received back, for local display
            // Use the *original* messageText, not the one with MSG_PREFIX
            // Ensure it includes the username for correct parsing by addMessageToChat
            const localEchoMessage = `[${getCurrentTimestamp()}] [${username}]: ${messageText}`;
            // console.log("DEBUG: Adding local echo:", localEchoMessage);
            addMessageToChat(localEchoMessage); // Display locally immediately
            // --- END LOCAL ECHO ---

        } catch (sendError) {
             console.error("DEBUG: Error during websocket.send():", sendError); // Debug log for send errors
             addMessageToChat("[Client Info] Error al enviar mensaje.");
        }
    } else {
        // Log why sending failed
        // console.warn("DEBUG: Send condition not met."); // Debug log
        if (!websocket) {
             console.warn("DEBUG: Reason: websocket object is null or undefined.");
        } else {
             console.warn(`DEBUG: Reason: websocket.readyState is ${websocket.readyState}, expected ${WebSocket.OPEN}.`);
        }
        addMessageToChat("[Client Info] No se pudo enviar el mensaje. No conectado o conexiÃ³n no lista.");
    }

    messageInput.value = ''; // Clear the input field
    messageInput.focus(); // Keep focus on the input field
});

// --- Initial State Setup ---
// console.log("DEBUG: Initializing UI state."); // Debug log
updateUIState(false);
loginModal.classList.remove('hidden');

