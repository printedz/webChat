// IMPORTANT: Replace with your WebSocket bridge URL if you implement one
const WEBSOCKET_SERVER_URL = "ws://localhost:8080"; // Example URL
const USER_PREFIX = "USER:";
const MSG_PREFIX = "MSG:";
const CMD_HELP = "/help";
const CMD_USERS = "/users";

let websocket = null;
let username = null;
let users = [];
let isConnected = false;

// --- DOM Elements ---
const loginModal = document.getElementById('loginModal');
const loginForm = document.getElementById('loginForm');
const usernameInput = document.getElementById('usernameInput');
const connectButton = document.getElementById('connectButton');
const loginError = document.getElementById('loginError');

const chatbox = document.getElementById('chatbox');
const chatboxWrapper = document.getElementById('chatboxWrapper');
const messageForm = document.getElementById('messageForm');
const messageInput = document.getElementById('messageInput');
const sendButton = document.getElementById('sendButton');
const statusDiv = document.getElementById('status');
const userListUl = document.getElementById('userList');
const userCountSpan = document.getElementById('userCount');

// --- Utility Functions ---

/**
 * Gets the current time formatted as HH:MM:SS.
 * @returns {string} Formatted timestamp.
 */
function getCurrentTimestamp() {
    const now = new Date();
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    return `${hours}:${minutes}:${seconds}`;
}

/**
 * Validates the username format (client-side).
 * @param {string} name - The username to validate.
 * @returns {boolean} True if the format is valid, false otherwise.
 */
function isValidUsername(name) {
    if (!name || name.length < 3 || name.length > 15) return false;
    // Allow letters, numbers, underscore, hyphen. No spaces.
    return /^[a-zA-Z0-9_-]+$/.test(name);
}

/**
 * Scrolls the chatbox to the bottom (most recent message).
 */
function scrollToBottom() {
    // Scroll the wrapper to the top because its content is reversed via CSS
    chatboxWrapper.scrollTop = 0;
}

/**
 * Adds a message to the chat interface, parsing and styling it appropriately.
 * @param {string} rawMessage - The raw message string received from the server or generated by the client.
 */
function addMessageToChat(rawMessage) {
    const messageContainer = document.createElement('div');
    messageContainer.classList.add('message-container');

    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');

    const messageP = document.createElement('p');
    messageP.classList.add('message-content');

    const timeP = document.createElement('p');
    timeP.classList.add('timestamp');

    let sender = null;
    let content = rawMessage;
    let timestamp = getCurrentTimestamp(); // Default to now if parsing fails
    let messageType = 'system'; // default type

    // Try to parse server format: "[HH:mm:ss] [Sender]: Content"
    const timeMatch = rawMessage.match(/^\[(\d{2}:\d{2}:\d{2})\]\s?/);
    if (timeMatch) {
        timestamp = timeMatch[1];
        content = rawMessage.substring(timeMatch[0].length).trim(); // Remove timestamp part

        const systemMatch = content.match(/^\[(Sistema)\]:\s?/i); // Check specifically for System (case-insensitive)
        const senderMatch = content.match(/^\[(.*?)\]:\s?/); // General sender match

        if (systemMatch) {
            sender = systemMatch[1]; // "Sistema" (preserve original case if needed)
            content = content.substring(systemMatch[0].length);
            messageType = 'system';
            messageDiv.classList.add('system-message');
            messageContainer.classList.add('self-center'); // Center system messages via container
        } else if (senderMatch) {
            sender = senderMatch[1];
            content = content.substring(senderMatch[0].length);
            if (sender === username) {
                messageType = 'my-message';
                messageDiv.classList.add('my-message');
                messageContainer.classList.add('self-end'); // Align own messages right
            } else {
                messageType = 'other-user';
                messageDiv.classList.add('other-message');
                messageContainer.classList.add('self-start'); // Align others' messages left
            }
        } else {
            // Assume system message if no sender format after time, but content exists
            messageType = 'system';
            messageDiv.classList.add('system-message');
            messageContainer.classList.add('self-center');
            sender = 'Sistema'; // Assume system if format is unclear
            // Keep 'content' as is, since there was no sender prefix
        }
    } else {
        // If no timestamp, treat as plain client-side info/error message
        messageType = 'client-info';
        messageDiv.classList.add('client-info-message'); // Use a specific class
        messageContainer.classList.add('self-center'); // Center client errors
        sender = 'Client Info';
        // Content remains rawMessage
    }

    // Add sender prefix using a span, styled by CSS based on message type
    const senderSpan = document.createElement('span');
    senderSpan.classList.add('sender'); // Base class for potential common styling
    if (sender) {
        // Add specific sender class based on type
        senderSpan.classList.add(`${messageType}-sender`);
        senderSpan.textContent = `[${sender}]: `;

        // Prepend sender span only if it's not the user's own message
        // (or adjust logic if you want "[You]:" prefix)
        if (messageType !== 'my-message') {
             messageP.appendChild(senderSpan);
        }
    }

    messageP.appendChild(document.createTextNode(content)); // Add actual message content
    timeP.textContent = timestamp;

    messageDiv.appendChild(messageP);
    // Only add timestamp if it's not a client-info message (or adjust as needed)
    if (messageType !== 'client-info') {
        messageDiv.appendChild(timeP);
    }
    messageContainer.appendChild(messageDiv);

    // Insert message at the 'top' because of flex-direction: column-reverse on chatbox
    chatbox.insertBefore(messageContainer, chatbox.firstChild);

    // Special handling for user list updates triggered by system messages
    if (messageType === 'system' && content.toLowerCase().startsWith('usuarios conectados')) {
        parseAndUpdateUserList(content);
    }

    scrollToBottom(); // Ensure view scrolls to the new message
}


/**
 * Updates the user list display in the sidebar.
 */
function updateUserListDisplay() {
    userListUl.innerHTML = ''; // Clear existing list
    // Sort users alphabetically, case-insensitive
    users.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
    users.forEach(user => {
        const li = document.createElement('li');
        li.textContent = user;
        // Styling (including the green dot) is handled by CSS rules for .user-list li
        userListUl.appendChild(li);
    });
    userCountSpan.textContent = users.length; // Update user count display
}

/**
 * Parses the user list string from the server and updates the local 'users' array.
 * Expected format: "Usuarios conectados (N): Alice, Bob, ..."
 * @param {string} userListString - The raw user list string from the server.
 */
function parseAndUpdateUserList(userListString) {
    // Extract content after the colon, trim whitespace
    const userPartMatch = userListString.match(/:\s*(.*)$/);
    const userPart = userPartMatch ? userPartMatch[1].trim() : '';

    if (userPart && userPart.toLowerCase() !== '(ninguno)') {
        // Split by comma, trim each name, filter out any empty strings
        users = userPart.split(',')
                      .map(name => name.trim())
                      .filter(name => name.length > 0);
    } else {
        users = []; // Set to empty list if "(ninguno)" or no users listed
    }
    updateUserListDisplay(); // Refresh the displayed list
}


/**
 * Updates the UI elements (input fields, status message, modal visibility) based on connection status.
 * @param {boolean} connected - True if connected, false otherwise.
 */
function updateUIState(connected) {
    isConnected = connected;
    if (connected) {
        loginModal.classList.add('hidden'); // Hide login modal using CSS class
        messageInput.disabled = false;
        sendButton.disabled = false;
        statusDiv.textContent = `Estado: Conectado como ${username}`;
        statusDiv.style.color = '#a5d6a7'; // Light green for connected status
        messageInput.focus(); // Focus input field when connected
    } else {
        // Show login modal if disconnected
        loginModal.classList.remove('hidden');
        messageInput.disabled = true;
        sendButton.disabled = true;
        username = null; // Clear username on disconnect
        users = []; // Clear user list on disconnect
        updateUserListDisplay(); // Update display to show 0 users
        statusDiv.textContent = "Estado: Desconectado";
        statusDiv.style.color = '#ef9a9a'; // Light red for disconnected status
        loginError.textContent = ''; // Clear login errors if any
    }
}


// --- WebSocket Event Handlers ---

/**
 * Called when the WebSocket connection is successfully opened.
 * Sends the initial USER identification command.
 * @param {Event} event - The WebSocket open event.
 */
function handleOpen(event) {
    console.log("WebSocket connection opened");
    loginError.textContent = ''; // Clear any previous login errors
    // Send the USER command to identify the client
    const userCommand = `${USER_PREFIX}${username}`;
    console.log("Sending identification:", userCommand);
    websocket.send(userCommand);
    // Update status temporarily; final state set upon receiving welcome message
    statusDiv.textContent = `Estado: Identificando como ${username}...`;
    statusDiv.style.color = '#fff59d'; // Light yellow for identifying status
}

/**
 * Called when a message is received from the WebSocket server.
 * Parses the message and updates the chat UI.
 * @param {MessageEvent} event - The WebSocket message event, data is in event.data.
 */
function handleMessage(event) {
    const message = event.data;
    console.log("Received message:", message);

    // Check specifically for the welcome message to confirm successful authentication
    if (message.includes(`¡Bienvenido al chat, ${username}!`)) {
        // Only update state if not already marked as connected
        // (prevents issues if server somehow resends welcome message)
        if (!isConnected) {
            updateUIState(true); // Mark as fully connected *after* receiving welcome
        }
    }

    addMessageToChat(message); // Add any message received to the chatbox display
}

/**
 * Called when a WebSocket error occurs.
 * Logs the error and updates the UI.
 * @param {Event} event - The WebSocket error event.
 */
function handleError(event) {
    console.error("WebSocket Error:", event);
    addMessageToChat(`[Client Info] Error de WebSocket. Revisa la consola.`);
    // Show error on login modal only if it's currently visible (i.e., connection failed)
    if (!loginModal.classList.contains('hidden')) {
        loginError.textContent = "Error de conexión.";
    }
    updateUIState(false); // Set UI to disconnected state
}

/**
 * Called when the WebSocket connection is closed.
 * Updates the UI and logs the closure reason.
 * @param {CloseEvent} event - The WebSocket close event (includes code and reason).
 */
function handleClose(event) {
    console.log("WebSocket connection closed:", `Code: ${event.code}`, `Reason: ${event.reason}`, `Was clean: ${event.wasClean}`);
    const wasConnected = isConnected; // Store previous connection state

    updateUIState(false); // Set UI to disconnected state first

    if (wasConnected) {
        // If we were previously connected, inform the user in chat
        addMessageToChat(`[Client Info] Desconectado del servidor.`);
    } else if (!event.wasClean && username) {
        // If connection closes uncleanly *before* being fully established (isConnected=false)
        // it likely means the server rejected the connection (e.g., username taken)
        loginError.textContent = "Fallo al conectar. Nombre en uso o servidor caído.";
        // No need to add chat message here as the login modal is visible
    }
    websocket = null; // Clear the WebSocket object reference
}

// --- Connection Logic ---

/**
 * Attempts to establish a WebSocket connection to the server.
 * @param {string} chosenUsername - The username selected by the user.
 */
function connect(chosenUsername) {
    // Basic client-side validation
    if (!isValidUsername(chosenUsername)) {
        loginError.textContent = "Formato de nombre de usuario inválido.";
        return;
    }
    username = chosenUsername;
    loginError.textContent = ''; // Clear previous errors
    statusDiv.textContent = "Estado: Conectando...";
    statusDiv.style.color = '#fff59d'; // Light yellow for connecting status

    // ** IMPORTANT: Choose EITHER Real WebSocket OR Simulation **

    // --- Start Real WebSocket Code ---
    // (Uncomment this block and comment out the Simulation block below for real usage)
    try {
        // Optional: Get server address from an input field if needed
        // const wsUrl = document.getElementById('serverAddressInput')?.value || WEBSOCKET_SERVER_URL;
        const wsUrl = WEBSOCKET_SERVER_URL; // Use the constant defined at the top
        console.log(`Attempting to connect to WebSocket server: ${wsUrl}`);

        // Create the WebSocket connection
        websocket = new WebSocket(wsUrl);

        // Assign event handlers
        websocket.onopen = handleOpen;
        websocket.onmessage = handleMessage;
        websocket.onerror = handleError;
        websocket.onclose = handleClose;

    } catch (error) {
         console.error("Failed to create WebSocket:", error);
         loginError.textContent = "Fallo al iniciar conexión.";
         statusDiv.textContent = "Estado: Error";
         statusDiv.style.color = '#ef9a9a'; // Light red for error status
         updateUIState(false); // Ensure UI is reset to disconnected
    }
    // --- End Real WebSocket Code ---


    // --- Start Simulation Code ---
    // (Comment out or remove this block if using Real WebSocket code above)
    /*
    console.log("SIMULATING Connection for:", username);
    // Simulate server accepting the username after a short delay
    setTimeout(() => {
        // Simulate receiving the sequence of messages a real server would send upon connection
        // Use handleMessage to process them as if received over WebSocket
        handleMessage({ data: `[${getCurrentTimestamp()}] [Sistema] ¡Bienvenido al chat, ${username}!` });
        handleMessage({ data: `[${getCurrentTimestamp()}] [Sistema] --- Inicio del Historial Reciente ---` });
        handleMessage({ data: `[${getCurrentTimestamp()}] [Sistema] No hay mensajes previos en el historial.` }); // Simulate empty history
        handleMessage({ data: `[${getCurrentTimestamp()}] [Sistema] --- Fin del Historial Reciente ---` });

        // Simulate user joining and initial user list
        users = [username]; // Add self to user list (simulation only)
        handleMessage({ data: `[${getCurrentTimestamp()}] [Sistema] ${username} se ha unido al chat.` });
        handleMessage({ data: `[${getCurrentTimestamp()}] [Sistema] Usuarios conectados (1): ${username}` });
        // Note: updateUIState(true) is called implicitly by the welcome message handler

        // --- Simulate other users joining/messaging (optional) ---
        setTimeout(() => {
           if(!isConnected) return; // Don't simulate if disconnected
           const newUser = "Alice";
           users.push(newUser); // Add Alice to simulated list
           handleMessage({ data: `[${getCurrentTimestamp()}] [Sistema] ${newUser} se ha unido al chat.` });
           handleMessage({ data: `[${getCurrentTimestamp()}] [Sistema] Usuarios conectados (${users.length}): ${users.join(', ')}` });
        }, 5000); // Alice joins after 5 seconds

        setTimeout(() => {
            if(!isConnected) return;
            handleMessage({ data: `[${getCurrentTimestamp()}] [Alice]: ¡Hola ${username}!` });
        }, 7000); // Alice messages after 7 seconds
        // --- End optional simulation ---

    }, 1000); // Simulate 1 second delay for connection process
    */
    // --- End Simulation Code ---

}

// --- Event Listeners ---

/**
 * Handles the submission of the login form.
 */
loginForm.addEventListener('submit', (e) => {
    e.preventDefault(); // Prevent default form submission
    connect(usernameInput.value.trim()); // Attempt to connect with the entered username
});

/**
 * Handles the submission of the message input form.
 */
messageForm.addEventListener('submit', (e) => {
    e.preventDefault(); // Prevent default form submission
    const messageText = messageInput.value.trim();

    // Don't send empty messages or if not connected
    if (!messageText || !isConnected) {
        return;
    }

    let messageToSend;
    // Check if the input is a known command, otherwise format as a standard message
    if (messageText.toLowerCase() === CMD_HELP || messageText.toLowerCase() === CMD_USERS) {
        // Server expects commands prefixed with MSG: as well
        messageToSend = `${MSG_PREFIX}${messageText}`;
    } else {
        // Regular chat message
        messageToSend = `${MSG_PREFIX}${messageText}`;
    }

    console.log("Attempting to send message:", messageToSend);

    // Send the message via WebSocket if connected and ready
    if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(messageToSend);

        // Optional: Add the user's own message to the chat immediately for better perceived responsiveness.
        // The server will likely echo it back, which addMessageToChat can handle (or you could add logic to prevent duplicates).
        // addMessageToChat(`[${getCurrentTimestamp()}] [${username}]: ${messageText}`); // Simulates local echo

    } else {
        // Handle case where WebSocket is not ready (or in simulation mode without WebSocket object)
        console.warn("WebSocket not open or not initialized. Message not sent.");
        // Optionally inform the user in the chat
        addMessageToChat("[Client Info] No se pudo enviar el mensaje. No conectado.");

        // --- Simulation Send Response ---
        // (If using simulation code, you might add simulated server responses here)
        /*
        console.log("SIMULATING Send:", messageToSend);
        // Add the message *as if* sent by the user (already done by local echo simulation above)
        // Simulate server responses for commands
        if (messageText.toLowerCase() === CMD_HELP) {
             setTimeout(() => {
                if(!isConnected) return;
                 handleMessage({ data: `[${getCurrentTimestamp()}] [Sistema] --- Ayuda ---` });
                 // ... add other help lines ...
                 handleMessage({ data: `[${getCurrentTimestamp()}] [Sistema] --- Fin Ayuda ---` });
            }, 300);
        } else if (messageText.toLowerCase() === CMD_USERS) {
            setTimeout(() => {
                if(!isConnected) return;
                 handleMessage({ data: `[${getCurrentTimestamp()}] [Sistema] Usuarios conectados (${users.length}): ${users.join(', ')}` });
             }, 300);
         }
         */
         // --- End Simulation Send Response ---
    }

    messageInput.value = ''; // Clear the input field after sending
    messageInput.focus(); // Keep focus on the input field
});

// --- Initial State Setup ---
// Ensure the UI starts in the disconnected state when the script loads.
updateUIState(false);
// Explicitly ensure the login modal is visible initially (updateUIState(false) should already do this)
loginModal.classList.remove('hidden');